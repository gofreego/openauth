// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             (unknown)
// source: proto/openauth/v1/openauth.proto

package openauth_v1

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	OpenAuth_Ping_FullMethodName                        = "/v1.OpenAuth/Ping"
	OpenAuth_CreatePermission_FullMethodName            = "/v1.OpenAuth/CreatePermission"
	OpenAuth_GetPermission_FullMethodName               = "/v1.OpenAuth/GetPermission"
	OpenAuth_ListPermissions_FullMethodName             = "/v1.OpenAuth/ListPermissions"
	OpenAuth_UpdatePermission_FullMethodName            = "/v1.OpenAuth/UpdatePermission"
	OpenAuth_DeletePermission_FullMethodName            = "/v1.OpenAuth/DeletePermission"
	OpenAuth_CreateGroup_FullMethodName                 = "/v1.OpenAuth/CreateGroup"
	OpenAuth_GetGroup_FullMethodName                    = "/v1.OpenAuth/GetGroup"
	OpenAuth_ListGroups_FullMethodName                  = "/v1.OpenAuth/ListGroups"
	OpenAuth_UpdateGroup_FullMethodName                 = "/v1.OpenAuth/UpdateGroup"
	OpenAuth_DeleteGroup_FullMethodName                 = "/v1.OpenAuth/DeleteGroup"
	OpenAuth_AssignUserToGroup_FullMethodName           = "/v1.OpenAuth/AssignUserToGroup"
	OpenAuth_RemoveUserFromGroup_FullMethodName         = "/v1.OpenAuth/RemoveUserFromGroup"
	OpenAuth_ListGroupUsers_FullMethodName              = "/v1.OpenAuth/ListGroupUsers"
	OpenAuth_ListUserGroups_FullMethodName              = "/v1.OpenAuth/ListUserGroups"
	OpenAuth_AssignPermissionToGroup_FullMethodName     = "/v1.OpenAuth/AssignPermissionToGroup"
	OpenAuth_RemovePermissionFromGroup_FullMethodName   = "/v1.OpenAuth/RemovePermissionFromGroup"
	OpenAuth_ListGroupPermissions_FullMethodName        = "/v1.OpenAuth/ListGroupPermissions"
	OpenAuth_AssignPermissionToUser_FullMethodName      = "/v1.OpenAuth/AssignPermissionToUser"
	OpenAuth_RemovePermissionFromUser_FullMethodName    = "/v1.OpenAuth/RemovePermissionFromUser"
	OpenAuth_ListUserPermissions_FullMethodName         = "/v1.OpenAuth/ListUserPermissions"
	OpenAuth_GetUserEffectivePermissions_FullMethodName = "/v1.OpenAuth/GetUserEffectivePermissions"
	OpenAuth_SignUp_FullMethodName                      = "/v1.OpenAuth/SignUp"
	OpenAuth_VerifyEmail_FullMethodName                 = "/v1.OpenAuth/VerifyEmail"
	OpenAuth_VerifyPhone_FullMethodName                 = "/v1.OpenAuth/VerifyPhone"
	OpenAuth_ResendVerification_FullMethodName          = "/v1.OpenAuth/ResendVerification"
	OpenAuth_CheckUsername_FullMethodName               = "/v1.OpenAuth/CheckUsername"
	OpenAuth_CheckEmail_FullMethodName                  = "/v1.OpenAuth/CheckEmail"
	OpenAuth_GetUser_FullMethodName                     = "/v1.OpenAuth/GetUser"
	OpenAuth_UpdateUser_FullMethodName                  = "/v1.OpenAuth/UpdateUser"
	OpenAuth_ChangePassword_FullMethodName              = "/v1.OpenAuth/ChangePassword"
	OpenAuth_ListUsers_FullMethodName                   = "/v1.OpenAuth/ListUsers"
	OpenAuth_DeleteUser_FullMethodName                  = "/v1.OpenAuth/DeleteUser"
	OpenAuth_CreateProfile_FullMethodName               = "/v1.OpenAuth/CreateProfile"
	OpenAuth_ListUserProfiles_FullMethodName            = "/v1.OpenAuth/ListUserProfiles"
	OpenAuth_UpdateProfile_FullMethodName               = "/v1.OpenAuth/UpdateProfile"
	OpenAuth_DeleteProfile_FullMethodName               = "/v1.OpenAuth/DeleteProfile"
	OpenAuth_SignIn_FullMethodName                      = "/v1.OpenAuth/SignIn"
	OpenAuth_RefreshToken_FullMethodName                = "/v1.OpenAuth/RefreshToken"
	OpenAuth_Logout_FullMethodName                      = "/v1.OpenAuth/Logout"
	OpenAuth_ValidateToken_FullMethodName               = "/v1.OpenAuth/ValidateToken"
	OpenAuth_ListUserSessions_FullMethodName            = "/v1.OpenAuth/ListUserSessions"
	OpenAuth_TerminateSession_FullMethodName            = "/v1.OpenAuth/TerminateSession"
)

// OpenAuthClient is the client API for OpenAuth service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// OpenAuth service provides authentication and authorization functionality
// including user management, permissions, groups, and session management.
type OpenAuthClient interface {
	// Ping is a simple health check endpoint to verify service availability
	Ping(ctx context.Context, in *PingRequest, opts ...grpc.CallOption) (*PingResponse, error)
	// CreatePermission creates a new permission in the system.
	//
	// Permissions follow the pattern: resource.action (e.g., "users.create")
	// - resource: The entity being accessed (users, groups, permissions, etc.)
	// - action: The operation being performed (create, read, update, delete, etc.)
	//
	// Example: Creating a permission for user management would have:
	// - name: "users.create"
	// - resource: "users"
	// - action: "create"
	// - display_name: "Create Users"
	CreatePermission(ctx context.Context, in *CreatePermissionRequest, opts ...grpc.CallOption) (*Permission, error)
	// GetPermission retrieves a specific permission by its unique ID.
	//
	// Returns the complete permission details including resource, action,
	// system status, and metadata.
	GetPermission(ctx context.Context, in *GetPermissionRequest, opts ...grpc.CallOption) (*Permission, error)
	// ListPermissions retrieves permissions with optional filtering and pagination.
	//
	// Supports filtering by:
	// - search: Searches across name, display_name, and description fields
	// - resource: Filter by specific resource type (e.g., "users", "groups")
	// - action: Filter by specific action type (e.g., "create", "read")
	// - is_system: Filter by system vs user-created permissions
	//
	// Pagination is handled via limit/offset parameters:
	// - limit: Maximum number of results (default: 10, max: 100)
	// - offset: Number of results to skip (default: 0)
	//
	// Example queries:
	// - GET /openauth/v1/permissions?resource=users - All user-related permissions
	// - GET /openauth/v1/permissions?action=create - All creation permissions
	// - GET /openauth/v1/permissions?search=user&limit=20 - Search for "user" with 20 results
	ListPermissions(ctx context.Context, in *ListPermissionsRequest, opts ...grpc.CallOption) (*ListPermissionsResponse, error)
	// UpdatePermission modifies an existing permission.
	//
	// All fields in the request are optional - only provided fields will be updated.
	// System permissions (is_system=true) cannot be modified to prevent
	// breaking core application functionality.
	//
	// Note: Changing the name requires ensuring uniqueness across all permissions.
	UpdatePermission(ctx context.Context, in *UpdatePermissionRequest, opts ...grpc.CallOption) (*Permission, error)
	// DeletePermission removes a permission from the system.
	//
	// System permissions (is_system=true) cannot be deleted as they are
	// critical for application functionality. Attempting to delete a system
	// permission will return a PermissionDenied error.
	//
	// Warning: Deleting a permission will affect all users and groups
	// that currently have this permission assigned.
	DeletePermission(ctx context.Context, in *DeletePermissionRequest, opts ...grpc.CallOption) (*DeletePermissionResponse, error)
	// CreateGroup creates a new group in the system.
	//
	// Groups are used to organize users and assign permissions collectively.
	// Each group has a unique name and can have multiple users and permissions assigned.
	CreateGroup(ctx context.Context, in *CreateGroupRequest, opts ...grpc.CallOption) (*CreateGroupResponse, error)
	// GetGroup retrieves a specific group by ID, UUID, or name.
	//
	// Returns complete group information including metadata and system status.
	GetGroup(ctx context.Context, in *GetGroupRequest, opts ...grpc.CallOption) (*GetGroupResponse, error)
	// ListGroups retrieves groups with optional filtering and pagination.
	//
	// Supports filtering by:
	// - search: Searches across name, display_name, and description fields
	// - is_system: Filter by system vs user-created groups
	// - is_default: Filter by default groups for new users
	ListGroups(ctx context.Context, in *ListGroupsRequest, opts ...grpc.CallOption) (*ListGroupsResponse, error)
	// UpdateGroup modifies an existing group.
	//
	// All fields in the request are optional - only provided fields will be updated.
	// System groups (is_system=true) cannot be modified to prevent breaking core functionality.
	UpdateGroup(ctx context.Context, in *UpdateGroupRequest, opts ...grpc.CallOption) (*UpdateGroupResponse, error)
	// DeleteGroup removes a group from the system.
	//
	// System groups (is_system=true) cannot be deleted as they are critical for application functionality.
	// Warning: Deleting a group will remove all user assignments and group permissions.
	DeleteGroup(ctx context.Context, in *DeleteGroupRequest, opts ...grpc.CallOption) (*DeleteGroupResponse, error)
	// AssignUserToGroup adds a user to a group.
	//
	// Grants the user all permissions associated with the group.
	// Supports optional expiration time for temporary group membership.
	AssignUserToGroup(ctx context.Context, in *AssignUserToGroupRequest, opts ...grpc.CallOption) (*AssignUserToGroupResponse, error)
	// RemoveUserFromGroup removes a user from a group.
	//
	// Revokes all group-based permissions from the user.
	// Direct user permissions are not affected.
	RemoveUserFromGroup(ctx context.Context, in *RemoveUserFromGroupRequest, opts ...grpc.CallOption) (*RemoveUserFromGroupResponse, error)
	// ListGroupUsers retrieves all users in a specific group.
	//
	// Returns paginated list of users with their group membership details.
	ListGroupUsers(ctx context.Context, in *ListGroupUsersRequest, opts ...grpc.CallOption) (*ListGroupUsersResponse, error)
	// ListUserGroups retrieves all groups for a specific user.
	//
	// Returns paginated list of groups the user belongs to.
	ListUserGroups(ctx context.Context, in *ListUserGroupsRequest, opts ...grpc.CallOption) (*ListUserGroupsResponse, error)
	// AssignPermissionToGroup assigns a permission to a group.
	//
	// This allows all users in the group to inherit this permission.
	// The permission will be available to all current and future group members.
	AssignPermissionToGroup(ctx context.Context, in *AssignPermissionToGroupRequest, opts ...grpc.CallOption) (*AssignPermissionToGroupResponse, error)
	// RemovePermissionFromGroup removes a permission from a group.
	//
	// This will remove the permission from all users who had it through group membership.
	// Users who have the same permission assigned directly will retain it.
	RemovePermissionFromGroup(ctx context.Context, in *RemovePermissionFromGroupRequest, opts ...grpc.CallOption) (*RemovePermissionFromGroupResponse, error)
	// ListGroupPermissions retrieves all permissions assigned to a specific group.
	//
	// Returns paginated list of permissions with optional search filtering.
	ListGroupPermissions(ctx context.Context, in *ListGroupPermissionsRequest, opts ...grpc.CallOption) (*ListGroupPermissionsResponse, error)
	// AssignPermissionToUser assigns a permission directly to a user.
	//
	// This creates a direct permission assignment that bypasses group membership.
	// Can include an optional expiration time for temporary permissions.
	AssignPermissionToUser(ctx context.Context, in *AssignPermissionToUserRequest, opts ...grpc.CallOption) (*AssignPermissionToUserResponse, error)
	// RemovePermissionFromUser removes a permission directly assigned to a user.
	//
	// This only removes direct permission assignments, not permissions inherited from groups.
	RemovePermissionFromUser(ctx context.Context, in *RemovePermissionFromUserRequest, opts ...grpc.CallOption) (*RemovePermissionFromUserResponse, error)
	// ListUserPermissions retrieves all permissions directly assigned to a user.
	//
	// This does not include permissions inherited from group membership.
	// Use GetUserEffectivePermissions to get all permissions including group-inherited ones.
	ListUserPermissions(ctx context.Context, in *ListUserPermissionsRequest, opts ...grpc.CallOption) (*ListUserPermissionsResponse, error)
	// GetUserEffectivePermissions retrieves all effective permissions for a user.
	//
	// This includes both directly assigned permissions and permissions inherited from group membership.
	// Each permission includes information about its source (direct assignment or group inheritance).
	GetUserEffectivePermissions(ctx context.Context, in *GetUserEffectivePermissionsRequest, opts ...grpc.CallOption) (*GetUserEffectivePermissionsResponse, error)
	// SignUp creates a new user account in the system.
	//
	// Supports multiple registration methods:
	// - Username + password (required)
	// - Email + password (optional, triggers email verification)
	// - Phone + password (optional, triggers SMS verification)
	//
	// Returns the created user and profile information along with
	// verification requirements if email/phone was provided.
	SignUp(ctx context.Context, in *SignUpRequest, opts ...grpc.CallOption) (*SignUpResponse, error)
	// VerifyEmail verifies a user's email address using a verification code.
	//
	// The verification code is typically sent via email during registration
	// or when requesting email verification. Successful verification
	// enables email-based features and login.
	VerifyEmail(ctx context.Context, in *VerifyEmailRequest, opts ...grpc.CallOption) (*VerificationResponse, error)
	// VerifyPhone verifies a user's phone number using a verification code.
	//
	// The verification code is typically sent via SMS during registration
	// or when requesting phone verification. Successful verification
	// enables SMS-based features and login.
	VerifyPhone(ctx context.Context, in *VerifyPhoneRequest, opts ...grpc.CallOption) (*VerificationResponse, error)
	// ResendVerification resends verification codes for email or phone.
	//
	// Useful when users don't receive the initial verification code
	// or when the code has expired. Includes rate limiting to prevent abuse.
	ResendVerification(ctx context.Context, in *SendVerificationCodeRequest, opts ...grpc.CallOption) (*SendVerificationCodeResponse, error)
	// CheckUsername checks if a username is available for registration.
	//
	// Returns availability status and suggestions for alternative usernames
	// if the requested username is already taken. Useful for real-time
	// username validation during registration.
	CheckUsername(ctx context.Context, in *CheckUsernameRequest, opts ...grpc.CallOption) (*CheckUsernameResponse, error)
	// CheckEmail checks if an email address is available for registration.
	//
	// Returns availability status for the email address. Used to prevent
	// duplicate registrations and provide user feedback during signup.
	CheckEmail(ctx context.Context, in *CheckEmailRequest, opts ...grpc.CallOption) (*CheckEmailResponse, error)
	// GetUser retrieves user information by ID, UUID, username, or email.
	//
	// Supports multiple identifier types and optional profile inclusion.
	// Access control should be enforced based on the requesting user's
	// permissions and relationship to the target user.
	GetUser(ctx context.Context, in *GetUserRequest, opts ...grpc.CallOption) (*GetUserResponse, error)
	// UpdateUser modifies user account and profile information.
	//
	// Supports partial updates - only provided fields are modified.
	// Sensitive operations like email/phone changes may require
	// additional verification steps.
	UpdateUser(ctx context.Context, in *UpdateUserRequest, opts ...grpc.CallOption) (*UpdateUserResponse, error)
	// ChangePassword allows users to change their password.
	//
	// Requires the current password for verification and the new password.
	// Triggers password change tracking and may invalidate existing sessions.
	ChangePassword(ctx context.Context, in *ChangePasswordRequest, opts ...grpc.CallOption) (*ChangePasswordResponse, error)
	// ListUsers retrieves users with filtering, sorting, and pagination.
	//
	// Supports filtering by:
	// - search: Search across username, email, and name fields
	// - is_active: Filter by account status
	// - email_verified/phone_verified: Filter by verification status
	//
	// Requires appropriate permissions to access user listings.
	ListUsers(ctx context.Context, in *ListUsersRequest, opts ...grpc.CallOption) (*ListUsersResponse, error)
	// DeleteUser removes or deactivates a user account.
	//
	// Supports both soft delete (deactivation) and hard delete.
	// Soft delete preserves data while preventing access.
	// Hard delete permanently removes the user and all associated data.
	DeleteUser(ctx context.Context, in *DeleteUserRequest, opts ...grpc.CallOption) (*DeleteUserResponse, error)
	// CreateProfile creates a new profile for a user.
	//
	// Allows users to create multiple profiles for different contexts.
	// Each profile can have different display information, preferences,
	// and metadata while belonging to the same user account.
	CreateProfile(ctx context.Context, in *CreateProfileRequest, opts ...grpc.CallOption) (*CreateProfileResponse, error)
	// ListUserProfiles retrieves all profiles for a specific user.
	//
	// Returns paginated list of profiles belonging to a user.
	// Useful for profile selection interfaces and management.
	ListUserProfiles(ctx context.Context, in *ListUserProfilesRequest, opts ...grpc.CallOption) (*ListUserProfilesResponse, error)
	// UpdateProfile modifies an existing profile.
	//
	// Supports partial updates - only provided fields are modified.
	// Profile updates are independent of user account information.
	UpdateProfile(ctx context.Context, in *UpdateProfileRequest, opts ...grpc.CallOption) (*UpdateProfileResponse, error)
	// DeleteProfile removes a specific profile.
	//
	// Permanently deletes a profile and all associated data.
	// Users must have at least one profile, so deletion of the last
	// profile may be restricted based on business rules.
	DeleteProfile(ctx context.Context, in *DeleteProfileRequest, opts ...grpc.CallOption) (*DeleteProfileResponse, error)
	// SignIn authenticates a user and creates a new session.
	//
	// Supports multiple login methods:
	// - Username + password
	// - Email + password
	// - Phone + password
	//
	// Returns access token, refresh token, and user information.
	// Tracks device information and manages session security.
	SignIn(ctx context.Context, in *SignInRequest, opts ...grpc.CallOption) (*SignInResponse, error)
	// RefreshToken generates new access token using refresh token.
	//
	// Implements token rotation for enhanced security where each refresh
	// generates a new refresh token and invalidates the old one.
	RefreshToken(ctx context.Context, in *RefreshTokenRequest, opts ...grpc.CallOption) (*RefreshTokenResponse, error)
	// Logout terminates user session(s).
	//
	// Can logout from current session or all sessions across devices.
	// Invalidates tokens and cleans up session data.
	Logout(ctx context.Context, in *LogoutRequest, opts ...grpc.CallOption) (*LogoutResponse, error)
	// ValidateToken checks if an access token is valid and active.
	//
	// Used for authentication middleware and token verification.
	// Returns user information if token is valid.
	ValidateToken(ctx context.Context, in *ValidateTokenRequest, opts ...grpc.CallOption) (*ValidateTokenResponse, error)
	// ListUserSessions retrieves active sessions for a user.
	//
	// Shows all devices and sessions where the user is logged in.
	// Useful for security management and device tracking.
	ListUserSessions(ctx context.Context, in *ListUserSessionsRequest, opts ...grpc.CallOption) (*ListUserSessionsResponse, error)
	// TerminateSession ends a specific user session.
	//
	// Allows users to logout from specific devices remotely.
	// Useful for security when a device is lost or compromised.
	TerminateSession(ctx context.Context, in *TerminateSessionRequest, opts ...grpc.CallOption) (*TerminateSessionResponse, error)
}

type openAuthClient struct {
	cc grpc.ClientConnInterface
}

func NewOpenAuthClient(cc grpc.ClientConnInterface) OpenAuthClient {
	return &openAuthClient{cc}
}

func (c *openAuthClient) Ping(ctx context.Context, in *PingRequest, opts ...grpc.CallOption) (*PingResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PingResponse)
	err := c.cc.Invoke(ctx, OpenAuth_Ping_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *openAuthClient) CreatePermission(ctx context.Context, in *CreatePermissionRequest, opts ...grpc.CallOption) (*Permission, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Permission)
	err := c.cc.Invoke(ctx, OpenAuth_CreatePermission_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *openAuthClient) GetPermission(ctx context.Context, in *GetPermissionRequest, opts ...grpc.CallOption) (*Permission, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Permission)
	err := c.cc.Invoke(ctx, OpenAuth_GetPermission_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *openAuthClient) ListPermissions(ctx context.Context, in *ListPermissionsRequest, opts ...grpc.CallOption) (*ListPermissionsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListPermissionsResponse)
	err := c.cc.Invoke(ctx, OpenAuth_ListPermissions_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *openAuthClient) UpdatePermission(ctx context.Context, in *UpdatePermissionRequest, opts ...grpc.CallOption) (*Permission, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Permission)
	err := c.cc.Invoke(ctx, OpenAuth_UpdatePermission_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *openAuthClient) DeletePermission(ctx context.Context, in *DeletePermissionRequest, opts ...grpc.CallOption) (*DeletePermissionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeletePermissionResponse)
	err := c.cc.Invoke(ctx, OpenAuth_DeletePermission_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *openAuthClient) CreateGroup(ctx context.Context, in *CreateGroupRequest, opts ...grpc.CallOption) (*CreateGroupResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateGroupResponse)
	err := c.cc.Invoke(ctx, OpenAuth_CreateGroup_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *openAuthClient) GetGroup(ctx context.Context, in *GetGroupRequest, opts ...grpc.CallOption) (*GetGroupResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetGroupResponse)
	err := c.cc.Invoke(ctx, OpenAuth_GetGroup_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *openAuthClient) ListGroups(ctx context.Context, in *ListGroupsRequest, opts ...grpc.CallOption) (*ListGroupsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListGroupsResponse)
	err := c.cc.Invoke(ctx, OpenAuth_ListGroups_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *openAuthClient) UpdateGroup(ctx context.Context, in *UpdateGroupRequest, opts ...grpc.CallOption) (*UpdateGroupResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateGroupResponse)
	err := c.cc.Invoke(ctx, OpenAuth_UpdateGroup_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *openAuthClient) DeleteGroup(ctx context.Context, in *DeleteGroupRequest, opts ...grpc.CallOption) (*DeleteGroupResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteGroupResponse)
	err := c.cc.Invoke(ctx, OpenAuth_DeleteGroup_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *openAuthClient) AssignUserToGroup(ctx context.Context, in *AssignUserToGroupRequest, opts ...grpc.CallOption) (*AssignUserToGroupResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AssignUserToGroupResponse)
	err := c.cc.Invoke(ctx, OpenAuth_AssignUserToGroup_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *openAuthClient) RemoveUserFromGroup(ctx context.Context, in *RemoveUserFromGroupRequest, opts ...grpc.CallOption) (*RemoveUserFromGroupResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RemoveUserFromGroupResponse)
	err := c.cc.Invoke(ctx, OpenAuth_RemoveUserFromGroup_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *openAuthClient) ListGroupUsers(ctx context.Context, in *ListGroupUsersRequest, opts ...grpc.CallOption) (*ListGroupUsersResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListGroupUsersResponse)
	err := c.cc.Invoke(ctx, OpenAuth_ListGroupUsers_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *openAuthClient) ListUserGroups(ctx context.Context, in *ListUserGroupsRequest, opts ...grpc.CallOption) (*ListUserGroupsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListUserGroupsResponse)
	err := c.cc.Invoke(ctx, OpenAuth_ListUserGroups_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *openAuthClient) AssignPermissionToGroup(ctx context.Context, in *AssignPermissionToGroupRequest, opts ...grpc.CallOption) (*AssignPermissionToGroupResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AssignPermissionToGroupResponse)
	err := c.cc.Invoke(ctx, OpenAuth_AssignPermissionToGroup_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *openAuthClient) RemovePermissionFromGroup(ctx context.Context, in *RemovePermissionFromGroupRequest, opts ...grpc.CallOption) (*RemovePermissionFromGroupResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RemovePermissionFromGroupResponse)
	err := c.cc.Invoke(ctx, OpenAuth_RemovePermissionFromGroup_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *openAuthClient) ListGroupPermissions(ctx context.Context, in *ListGroupPermissionsRequest, opts ...grpc.CallOption) (*ListGroupPermissionsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListGroupPermissionsResponse)
	err := c.cc.Invoke(ctx, OpenAuth_ListGroupPermissions_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *openAuthClient) AssignPermissionToUser(ctx context.Context, in *AssignPermissionToUserRequest, opts ...grpc.CallOption) (*AssignPermissionToUserResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AssignPermissionToUserResponse)
	err := c.cc.Invoke(ctx, OpenAuth_AssignPermissionToUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *openAuthClient) RemovePermissionFromUser(ctx context.Context, in *RemovePermissionFromUserRequest, opts ...grpc.CallOption) (*RemovePermissionFromUserResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RemovePermissionFromUserResponse)
	err := c.cc.Invoke(ctx, OpenAuth_RemovePermissionFromUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *openAuthClient) ListUserPermissions(ctx context.Context, in *ListUserPermissionsRequest, opts ...grpc.CallOption) (*ListUserPermissionsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListUserPermissionsResponse)
	err := c.cc.Invoke(ctx, OpenAuth_ListUserPermissions_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *openAuthClient) GetUserEffectivePermissions(ctx context.Context, in *GetUserEffectivePermissionsRequest, opts ...grpc.CallOption) (*GetUserEffectivePermissionsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetUserEffectivePermissionsResponse)
	err := c.cc.Invoke(ctx, OpenAuth_GetUserEffectivePermissions_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *openAuthClient) SignUp(ctx context.Context, in *SignUpRequest, opts ...grpc.CallOption) (*SignUpResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SignUpResponse)
	err := c.cc.Invoke(ctx, OpenAuth_SignUp_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *openAuthClient) VerifyEmail(ctx context.Context, in *VerifyEmailRequest, opts ...grpc.CallOption) (*VerificationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VerificationResponse)
	err := c.cc.Invoke(ctx, OpenAuth_VerifyEmail_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *openAuthClient) VerifyPhone(ctx context.Context, in *VerifyPhoneRequest, opts ...grpc.CallOption) (*VerificationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VerificationResponse)
	err := c.cc.Invoke(ctx, OpenAuth_VerifyPhone_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *openAuthClient) ResendVerification(ctx context.Context, in *SendVerificationCodeRequest, opts ...grpc.CallOption) (*SendVerificationCodeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SendVerificationCodeResponse)
	err := c.cc.Invoke(ctx, OpenAuth_ResendVerification_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *openAuthClient) CheckUsername(ctx context.Context, in *CheckUsernameRequest, opts ...grpc.CallOption) (*CheckUsernameResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CheckUsernameResponse)
	err := c.cc.Invoke(ctx, OpenAuth_CheckUsername_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *openAuthClient) CheckEmail(ctx context.Context, in *CheckEmailRequest, opts ...grpc.CallOption) (*CheckEmailResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CheckEmailResponse)
	err := c.cc.Invoke(ctx, OpenAuth_CheckEmail_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *openAuthClient) GetUser(ctx context.Context, in *GetUserRequest, opts ...grpc.CallOption) (*GetUserResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetUserResponse)
	err := c.cc.Invoke(ctx, OpenAuth_GetUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *openAuthClient) UpdateUser(ctx context.Context, in *UpdateUserRequest, opts ...grpc.CallOption) (*UpdateUserResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateUserResponse)
	err := c.cc.Invoke(ctx, OpenAuth_UpdateUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *openAuthClient) ChangePassword(ctx context.Context, in *ChangePasswordRequest, opts ...grpc.CallOption) (*ChangePasswordResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ChangePasswordResponse)
	err := c.cc.Invoke(ctx, OpenAuth_ChangePassword_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *openAuthClient) ListUsers(ctx context.Context, in *ListUsersRequest, opts ...grpc.CallOption) (*ListUsersResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListUsersResponse)
	err := c.cc.Invoke(ctx, OpenAuth_ListUsers_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *openAuthClient) DeleteUser(ctx context.Context, in *DeleteUserRequest, opts ...grpc.CallOption) (*DeleteUserResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteUserResponse)
	err := c.cc.Invoke(ctx, OpenAuth_DeleteUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *openAuthClient) CreateProfile(ctx context.Context, in *CreateProfileRequest, opts ...grpc.CallOption) (*CreateProfileResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateProfileResponse)
	err := c.cc.Invoke(ctx, OpenAuth_CreateProfile_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *openAuthClient) ListUserProfiles(ctx context.Context, in *ListUserProfilesRequest, opts ...grpc.CallOption) (*ListUserProfilesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListUserProfilesResponse)
	err := c.cc.Invoke(ctx, OpenAuth_ListUserProfiles_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *openAuthClient) UpdateProfile(ctx context.Context, in *UpdateProfileRequest, opts ...grpc.CallOption) (*UpdateProfileResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateProfileResponse)
	err := c.cc.Invoke(ctx, OpenAuth_UpdateProfile_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *openAuthClient) DeleteProfile(ctx context.Context, in *DeleteProfileRequest, opts ...grpc.CallOption) (*DeleteProfileResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteProfileResponse)
	err := c.cc.Invoke(ctx, OpenAuth_DeleteProfile_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *openAuthClient) SignIn(ctx context.Context, in *SignInRequest, opts ...grpc.CallOption) (*SignInResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SignInResponse)
	err := c.cc.Invoke(ctx, OpenAuth_SignIn_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *openAuthClient) RefreshToken(ctx context.Context, in *RefreshTokenRequest, opts ...grpc.CallOption) (*RefreshTokenResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RefreshTokenResponse)
	err := c.cc.Invoke(ctx, OpenAuth_RefreshToken_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *openAuthClient) Logout(ctx context.Context, in *LogoutRequest, opts ...grpc.CallOption) (*LogoutResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LogoutResponse)
	err := c.cc.Invoke(ctx, OpenAuth_Logout_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *openAuthClient) ValidateToken(ctx context.Context, in *ValidateTokenRequest, opts ...grpc.CallOption) (*ValidateTokenResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ValidateTokenResponse)
	err := c.cc.Invoke(ctx, OpenAuth_ValidateToken_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *openAuthClient) ListUserSessions(ctx context.Context, in *ListUserSessionsRequest, opts ...grpc.CallOption) (*ListUserSessionsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListUserSessionsResponse)
	err := c.cc.Invoke(ctx, OpenAuth_ListUserSessions_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *openAuthClient) TerminateSession(ctx context.Context, in *TerminateSessionRequest, opts ...grpc.CallOption) (*TerminateSessionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TerminateSessionResponse)
	err := c.cc.Invoke(ctx, OpenAuth_TerminateSession_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// OpenAuthServer is the server API for OpenAuth service.
// All implementations must embed UnimplementedOpenAuthServer
// for forward compatibility.
//
// OpenAuth service provides authentication and authorization functionality
// including user management, permissions, groups, and session management.
type OpenAuthServer interface {
	// Ping is a simple health check endpoint to verify service availability
	Ping(context.Context, *PingRequest) (*PingResponse, error)
	// CreatePermission creates a new permission in the system.
	//
	// Permissions follow the pattern: resource.action (e.g., "users.create")
	// - resource: The entity being accessed (users, groups, permissions, etc.)
	// - action: The operation being performed (create, read, update, delete, etc.)
	//
	// Example: Creating a permission for user management would have:
	// - name: "users.create"
	// - resource: "users"
	// - action: "create"
	// - display_name: "Create Users"
	CreatePermission(context.Context, *CreatePermissionRequest) (*Permission, error)
	// GetPermission retrieves a specific permission by its unique ID.
	//
	// Returns the complete permission details including resource, action,
	// system status, and metadata.
	GetPermission(context.Context, *GetPermissionRequest) (*Permission, error)
	// ListPermissions retrieves permissions with optional filtering and pagination.
	//
	// Supports filtering by:
	// - search: Searches across name, display_name, and description fields
	// - resource: Filter by specific resource type (e.g., "users", "groups")
	// - action: Filter by specific action type (e.g., "create", "read")
	// - is_system: Filter by system vs user-created permissions
	//
	// Pagination is handled via limit/offset parameters:
	// - limit: Maximum number of results (default: 10, max: 100)
	// - offset: Number of results to skip (default: 0)
	//
	// Example queries:
	// - GET /openauth/v1/permissions?resource=users - All user-related permissions
	// - GET /openauth/v1/permissions?action=create - All creation permissions
	// - GET /openauth/v1/permissions?search=user&limit=20 - Search for "user" with 20 results
	ListPermissions(context.Context, *ListPermissionsRequest) (*ListPermissionsResponse, error)
	// UpdatePermission modifies an existing permission.
	//
	// All fields in the request are optional - only provided fields will be updated.
	// System permissions (is_system=true) cannot be modified to prevent
	// breaking core application functionality.
	//
	// Note: Changing the name requires ensuring uniqueness across all permissions.
	UpdatePermission(context.Context, *UpdatePermissionRequest) (*Permission, error)
	// DeletePermission removes a permission from the system.
	//
	// System permissions (is_system=true) cannot be deleted as they are
	// critical for application functionality. Attempting to delete a system
	// permission will return a PermissionDenied error.
	//
	// Warning: Deleting a permission will affect all users and groups
	// that currently have this permission assigned.
	DeletePermission(context.Context, *DeletePermissionRequest) (*DeletePermissionResponse, error)
	// CreateGroup creates a new group in the system.
	//
	// Groups are used to organize users and assign permissions collectively.
	// Each group has a unique name and can have multiple users and permissions assigned.
	CreateGroup(context.Context, *CreateGroupRequest) (*CreateGroupResponse, error)
	// GetGroup retrieves a specific group by ID, UUID, or name.
	//
	// Returns complete group information including metadata and system status.
	GetGroup(context.Context, *GetGroupRequest) (*GetGroupResponse, error)
	// ListGroups retrieves groups with optional filtering and pagination.
	//
	// Supports filtering by:
	// - search: Searches across name, display_name, and description fields
	// - is_system: Filter by system vs user-created groups
	// - is_default: Filter by default groups for new users
	ListGroups(context.Context, *ListGroupsRequest) (*ListGroupsResponse, error)
	// UpdateGroup modifies an existing group.
	//
	// All fields in the request are optional - only provided fields will be updated.
	// System groups (is_system=true) cannot be modified to prevent breaking core functionality.
	UpdateGroup(context.Context, *UpdateGroupRequest) (*UpdateGroupResponse, error)
	// DeleteGroup removes a group from the system.
	//
	// System groups (is_system=true) cannot be deleted as they are critical for application functionality.
	// Warning: Deleting a group will remove all user assignments and group permissions.
	DeleteGroup(context.Context, *DeleteGroupRequest) (*DeleteGroupResponse, error)
	// AssignUserToGroup adds a user to a group.
	//
	// Grants the user all permissions associated with the group.
	// Supports optional expiration time for temporary group membership.
	AssignUserToGroup(context.Context, *AssignUserToGroupRequest) (*AssignUserToGroupResponse, error)
	// RemoveUserFromGroup removes a user from a group.
	//
	// Revokes all group-based permissions from the user.
	// Direct user permissions are not affected.
	RemoveUserFromGroup(context.Context, *RemoveUserFromGroupRequest) (*RemoveUserFromGroupResponse, error)
	// ListGroupUsers retrieves all users in a specific group.
	//
	// Returns paginated list of users with their group membership details.
	ListGroupUsers(context.Context, *ListGroupUsersRequest) (*ListGroupUsersResponse, error)
	// ListUserGroups retrieves all groups for a specific user.
	//
	// Returns paginated list of groups the user belongs to.
	ListUserGroups(context.Context, *ListUserGroupsRequest) (*ListUserGroupsResponse, error)
	// AssignPermissionToGroup assigns a permission to a group.
	//
	// This allows all users in the group to inherit this permission.
	// The permission will be available to all current and future group members.
	AssignPermissionToGroup(context.Context, *AssignPermissionToGroupRequest) (*AssignPermissionToGroupResponse, error)
	// RemovePermissionFromGroup removes a permission from a group.
	//
	// This will remove the permission from all users who had it through group membership.
	// Users who have the same permission assigned directly will retain it.
	RemovePermissionFromGroup(context.Context, *RemovePermissionFromGroupRequest) (*RemovePermissionFromGroupResponse, error)
	// ListGroupPermissions retrieves all permissions assigned to a specific group.
	//
	// Returns paginated list of permissions with optional search filtering.
	ListGroupPermissions(context.Context, *ListGroupPermissionsRequest) (*ListGroupPermissionsResponse, error)
	// AssignPermissionToUser assigns a permission directly to a user.
	//
	// This creates a direct permission assignment that bypasses group membership.
	// Can include an optional expiration time for temporary permissions.
	AssignPermissionToUser(context.Context, *AssignPermissionToUserRequest) (*AssignPermissionToUserResponse, error)
	// RemovePermissionFromUser removes a permission directly assigned to a user.
	//
	// This only removes direct permission assignments, not permissions inherited from groups.
	RemovePermissionFromUser(context.Context, *RemovePermissionFromUserRequest) (*RemovePermissionFromUserResponse, error)
	// ListUserPermissions retrieves all permissions directly assigned to a user.
	//
	// This does not include permissions inherited from group membership.
	// Use GetUserEffectivePermissions to get all permissions including group-inherited ones.
	ListUserPermissions(context.Context, *ListUserPermissionsRequest) (*ListUserPermissionsResponse, error)
	// GetUserEffectivePermissions retrieves all effective permissions for a user.
	//
	// This includes both directly assigned permissions and permissions inherited from group membership.
	// Each permission includes information about its source (direct assignment or group inheritance).
	GetUserEffectivePermissions(context.Context, *GetUserEffectivePermissionsRequest) (*GetUserEffectivePermissionsResponse, error)
	// SignUp creates a new user account in the system.
	//
	// Supports multiple registration methods:
	// - Username + password (required)
	// - Email + password (optional, triggers email verification)
	// - Phone + password (optional, triggers SMS verification)
	//
	// Returns the created user and profile information along with
	// verification requirements if email/phone was provided.
	SignUp(context.Context, *SignUpRequest) (*SignUpResponse, error)
	// VerifyEmail verifies a user's email address using a verification code.
	//
	// The verification code is typically sent via email during registration
	// or when requesting email verification. Successful verification
	// enables email-based features and login.
	VerifyEmail(context.Context, *VerifyEmailRequest) (*VerificationResponse, error)
	// VerifyPhone verifies a user's phone number using a verification code.
	//
	// The verification code is typically sent via SMS during registration
	// or when requesting phone verification. Successful verification
	// enables SMS-based features and login.
	VerifyPhone(context.Context, *VerifyPhoneRequest) (*VerificationResponse, error)
	// ResendVerification resends verification codes for email or phone.
	//
	// Useful when users don't receive the initial verification code
	// or when the code has expired. Includes rate limiting to prevent abuse.
	ResendVerification(context.Context, *SendVerificationCodeRequest) (*SendVerificationCodeResponse, error)
	// CheckUsername checks if a username is available for registration.
	//
	// Returns availability status and suggestions for alternative usernames
	// if the requested username is already taken. Useful for real-time
	// username validation during registration.
	CheckUsername(context.Context, *CheckUsernameRequest) (*CheckUsernameResponse, error)
	// CheckEmail checks if an email address is available for registration.
	//
	// Returns availability status for the email address. Used to prevent
	// duplicate registrations and provide user feedback during signup.
	CheckEmail(context.Context, *CheckEmailRequest) (*CheckEmailResponse, error)
	// GetUser retrieves user information by ID, UUID, username, or email.
	//
	// Supports multiple identifier types and optional profile inclusion.
	// Access control should be enforced based on the requesting user's
	// permissions and relationship to the target user.
	GetUser(context.Context, *GetUserRequest) (*GetUserResponse, error)
	// UpdateUser modifies user account and profile information.
	//
	// Supports partial updates - only provided fields are modified.
	// Sensitive operations like email/phone changes may require
	// additional verification steps.
	UpdateUser(context.Context, *UpdateUserRequest) (*UpdateUserResponse, error)
	// ChangePassword allows users to change their password.
	//
	// Requires the current password for verification and the new password.
	// Triggers password change tracking and may invalidate existing sessions.
	ChangePassword(context.Context, *ChangePasswordRequest) (*ChangePasswordResponse, error)
	// ListUsers retrieves users with filtering, sorting, and pagination.
	//
	// Supports filtering by:
	// - search: Search across username, email, and name fields
	// - is_active: Filter by account status
	// - email_verified/phone_verified: Filter by verification status
	//
	// Requires appropriate permissions to access user listings.
	ListUsers(context.Context, *ListUsersRequest) (*ListUsersResponse, error)
	// DeleteUser removes or deactivates a user account.
	//
	// Supports both soft delete (deactivation) and hard delete.
	// Soft delete preserves data while preventing access.
	// Hard delete permanently removes the user and all associated data.
	DeleteUser(context.Context, *DeleteUserRequest) (*DeleteUserResponse, error)
	// CreateProfile creates a new profile for a user.
	//
	// Allows users to create multiple profiles for different contexts.
	// Each profile can have different display information, preferences,
	// and metadata while belonging to the same user account.
	CreateProfile(context.Context, *CreateProfileRequest) (*CreateProfileResponse, error)
	// ListUserProfiles retrieves all profiles for a specific user.
	//
	// Returns paginated list of profiles belonging to a user.
	// Useful for profile selection interfaces and management.
	ListUserProfiles(context.Context, *ListUserProfilesRequest) (*ListUserProfilesResponse, error)
	// UpdateProfile modifies an existing profile.
	//
	// Supports partial updates - only provided fields are modified.
	// Profile updates are independent of user account information.
	UpdateProfile(context.Context, *UpdateProfileRequest) (*UpdateProfileResponse, error)
	// DeleteProfile removes a specific profile.
	//
	// Permanently deletes a profile and all associated data.
	// Users must have at least one profile, so deletion of the last
	// profile may be restricted based on business rules.
	DeleteProfile(context.Context, *DeleteProfileRequest) (*DeleteProfileResponse, error)
	// SignIn authenticates a user and creates a new session.
	//
	// Supports multiple login methods:
	// - Username + password
	// - Email + password
	// - Phone + password
	//
	// Returns access token, refresh token, and user information.
	// Tracks device information and manages session security.
	SignIn(context.Context, *SignInRequest) (*SignInResponse, error)
	// RefreshToken generates new access token using refresh token.
	//
	// Implements token rotation for enhanced security where each refresh
	// generates a new refresh token and invalidates the old one.
	RefreshToken(context.Context, *RefreshTokenRequest) (*RefreshTokenResponse, error)
	// Logout terminates user session(s).
	//
	// Can logout from current session or all sessions across devices.
	// Invalidates tokens and cleans up session data.
	Logout(context.Context, *LogoutRequest) (*LogoutResponse, error)
	// ValidateToken checks if an access token is valid and active.
	//
	// Used for authentication middleware and token verification.
	// Returns user information if token is valid.
	ValidateToken(context.Context, *ValidateTokenRequest) (*ValidateTokenResponse, error)
	// ListUserSessions retrieves active sessions for a user.
	//
	// Shows all devices and sessions where the user is logged in.
	// Useful for security management and device tracking.
	ListUserSessions(context.Context, *ListUserSessionsRequest) (*ListUserSessionsResponse, error)
	// TerminateSession ends a specific user session.
	//
	// Allows users to logout from specific devices remotely.
	// Useful for security when a device is lost or compromised.
	TerminateSession(context.Context, *TerminateSessionRequest) (*TerminateSessionResponse, error)
	mustEmbedUnimplementedOpenAuthServer()
}

// UnimplementedOpenAuthServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedOpenAuthServer struct{}

func (UnimplementedOpenAuthServer) Ping(context.Context, *PingRequest) (*PingResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Ping not implemented")
}
func (UnimplementedOpenAuthServer) CreatePermission(context.Context, *CreatePermissionRequest) (*Permission, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreatePermission not implemented")
}
func (UnimplementedOpenAuthServer) GetPermission(context.Context, *GetPermissionRequest) (*Permission, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPermission not implemented")
}
func (UnimplementedOpenAuthServer) ListPermissions(context.Context, *ListPermissionsRequest) (*ListPermissionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListPermissions not implemented")
}
func (UnimplementedOpenAuthServer) UpdatePermission(context.Context, *UpdatePermissionRequest) (*Permission, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdatePermission not implemented")
}
func (UnimplementedOpenAuthServer) DeletePermission(context.Context, *DeletePermissionRequest) (*DeletePermissionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeletePermission not implemented")
}
func (UnimplementedOpenAuthServer) CreateGroup(context.Context, *CreateGroupRequest) (*CreateGroupResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateGroup not implemented")
}
func (UnimplementedOpenAuthServer) GetGroup(context.Context, *GetGroupRequest) (*GetGroupResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetGroup not implemented")
}
func (UnimplementedOpenAuthServer) ListGroups(context.Context, *ListGroupsRequest) (*ListGroupsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListGroups not implemented")
}
func (UnimplementedOpenAuthServer) UpdateGroup(context.Context, *UpdateGroupRequest) (*UpdateGroupResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateGroup not implemented")
}
func (UnimplementedOpenAuthServer) DeleteGroup(context.Context, *DeleteGroupRequest) (*DeleteGroupResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteGroup not implemented")
}
func (UnimplementedOpenAuthServer) AssignUserToGroup(context.Context, *AssignUserToGroupRequest) (*AssignUserToGroupResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AssignUserToGroup not implemented")
}
func (UnimplementedOpenAuthServer) RemoveUserFromGroup(context.Context, *RemoveUserFromGroupRequest) (*RemoveUserFromGroupResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveUserFromGroup not implemented")
}
func (UnimplementedOpenAuthServer) ListGroupUsers(context.Context, *ListGroupUsersRequest) (*ListGroupUsersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListGroupUsers not implemented")
}
func (UnimplementedOpenAuthServer) ListUserGroups(context.Context, *ListUserGroupsRequest) (*ListUserGroupsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListUserGroups not implemented")
}
func (UnimplementedOpenAuthServer) AssignPermissionToGroup(context.Context, *AssignPermissionToGroupRequest) (*AssignPermissionToGroupResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AssignPermissionToGroup not implemented")
}
func (UnimplementedOpenAuthServer) RemovePermissionFromGroup(context.Context, *RemovePermissionFromGroupRequest) (*RemovePermissionFromGroupResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemovePermissionFromGroup not implemented")
}
func (UnimplementedOpenAuthServer) ListGroupPermissions(context.Context, *ListGroupPermissionsRequest) (*ListGroupPermissionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListGroupPermissions not implemented")
}
func (UnimplementedOpenAuthServer) AssignPermissionToUser(context.Context, *AssignPermissionToUserRequest) (*AssignPermissionToUserResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AssignPermissionToUser not implemented")
}
func (UnimplementedOpenAuthServer) RemovePermissionFromUser(context.Context, *RemovePermissionFromUserRequest) (*RemovePermissionFromUserResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemovePermissionFromUser not implemented")
}
func (UnimplementedOpenAuthServer) ListUserPermissions(context.Context, *ListUserPermissionsRequest) (*ListUserPermissionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListUserPermissions not implemented")
}
func (UnimplementedOpenAuthServer) GetUserEffectivePermissions(context.Context, *GetUserEffectivePermissionsRequest) (*GetUserEffectivePermissionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUserEffectivePermissions not implemented")
}
func (UnimplementedOpenAuthServer) SignUp(context.Context, *SignUpRequest) (*SignUpResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SignUp not implemented")
}
func (UnimplementedOpenAuthServer) VerifyEmail(context.Context, *VerifyEmailRequest) (*VerificationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VerifyEmail not implemented")
}
func (UnimplementedOpenAuthServer) VerifyPhone(context.Context, *VerifyPhoneRequest) (*VerificationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VerifyPhone not implemented")
}
func (UnimplementedOpenAuthServer) ResendVerification(context.Context, *SendVerificationCodeRequest) (*SendVerificationCodeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResendVerification not implemented")
}
func (UnimplementedOpenAuthServer) CheckUsername(context.Context, *CheckUsernameRequest) (*CheckUsernameResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CheckUsername not implemented")
}
func (UnimplementedOpenAuthServer) CheckEmail(context.Context, *CheckEmailRequest) (*CheckEmailResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CheckEmail not implemented")
}
func (UnimplementedOpenAuthServer) GetUser(context.Context, *GetUserRequest) (*GetUserResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUser not implemented")
}
func (UnimplementedOpenAuthServer) UpdateUser(context.Context, *UpdateUserRequest) (*UpdateUserResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateUser not implemented")
}
func (UnimplementedOpenAuthServer) ChangePassword(context.Context, *ChangePasswordRequest) (*ChangePasswordResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ChangePassword not implemented")
}
func (UnimplementedOpenAuthServer) ListUsers(context.Context, *ListUsersRequest) (*ListUsersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListUsers not implemented")
}
func (UnimplementedOpenAuthServer) DeleteUser(context.Context, *DeleteUserRequest) (*DeleteUserResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteUser not implemented")
}
func (UnimplementedOpenAuthServer) CreateProfile(context.Context, *CreateProfileRequest) (*CreateProfileResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateProfile not implemented")
}
func (UnimplementedOpenAuthServer) ListUserProfiles(context.Context, *ListUserProfilesRequest) (*ListUserProfilesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListUserProfiles not implemented")
}
func (UnimplementedOpenAuthServer) UpdateProfile(context.Context, *UpdateProfileRequest) (*UpdateProfileResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateProfile not implemented")
}
func (UnimplementedOpenAuthServer) DeleteProfile(context.Context, *DeleteProfileRequest) (*DeleteProfileResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteProfile not implemented")
}
func (UnimplementedOpenAuthServer) SignIn(context.Context, *SignInRequest) (*SignInResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SignIn not implemented")
}
func (UnimplementedOpenAuthServer) RefreshToken(context.Context, *RefreshTokenRequest) (*RefreshTokenResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RefreshToken not implemented")
}
func (UnimplementedOpenAuthServer) Logout(context.Context, *LogoutRequest) (*LogoutResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Logout not implemented")
}
func (UnimplementedOpenAuthServer) ValidateToken(context.Context, *ValidateTokenRequest) (*ValidateTokenResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ValidateToken not implemented")
}
func (UnimplementedOpenAuthServer) ListUserSessions(context.Context, *ListUserSessionsRequest) (*ListUserSessionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListUserSessions not implemented")
}
func (UnimplementedOpenAuthServer) TerminateSession(context.Context, *TerminateSessionRequest) (*TerminateSessionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TerminateSession not implemented")
}
func (UnimplementedOpenAuthServer) mustEmbedUnimplementedOpenAuthServer() {}
func (UnimplementedOpenAuthServer) testEmbeddedByValue()                  {}

// UnsafeOpenAuthServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to OpenAuthServer will
// result in compilation errors.
type UnsafeOpenAuthServer interface {
	mustEmbedUnimplementedOpenAuthServer()
}

func RegisterOpenAuthServer(s grpc.ServiceRegistrar, srv OpenAuthServer) {
	// If the following call pancis, it indicates UnimplementedOpenAuthServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&OpenAuth_ServiceDesc, srv)
}

func _OpenAuth_Ping_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OpenAuthServer).Ping(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OpenAuth_Ping_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OpenAuthServer).Ping(ctx, req.(*PingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OpenAuth_CreatePermission_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreatePermissionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OpenAuthServer).CreatePermission(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OpenAuth_CreatePermission_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OpenAuthServer).CreatePermission(ctx, req.(*CreatePermissionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OpenAuth_GetPermission_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPermissionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OpenAuthServer).GetPermission(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OpenAuth_GetPermission_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OpenAuthServer).GetPermission(ctx, req.(*GetPermissionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OpenAuth_ListPermissions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListPermissionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OpenAuthServer).ListPermissions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OpenAuth_ListPermissions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OpenAuthServer).ListPermissions(ctx, req.(*ListPermissionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OpenAuth_UpdatePermission_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdatePermissionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OpenAuthServer).UpdatePermission(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OpenAuth_UpdatePermission_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OpenAuthServer).UpdatePermission(ctx, req.(*UpdatePermissionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OpenAuth_DeletePermission_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeletePermissionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OpenAuthServer).DeletePermission(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OpenAuth_DeletePermission_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OpenAuthServer).DeletePermission(ctx, req.(*DeletePermissionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OpenAuth_CreateGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OpenAuthServer).CreateGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OpenAuth_CreateGroup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OpenAuthServer).CreateGroup(ctx, req.(*CreateGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OpenAuth_GetGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OpenAuthServer).GetGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OpenAuth_GetGroup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OpenAuthServer).GetGroup(ctx, req.(*GetGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OpenAuth_ListGroups_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListGroupsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OpenAuthServer).ListGroups(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OpenAuth_ListGroups_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OpenAuthServer).ListGroups(ctx, req.(*ListGroupsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OpenAuth_UpdateGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OpenAuthServer).UpdateGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OpenAuth_UpdateGroup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OpenAuthServer).UpdateGroup(ctx, req.(*UpdateGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OpenAuth_DeleteGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OpenAuthServer).DeleteGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OpenAuth_DeleteGroup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OpenAuthServer).DeleteGroup(ctx, req.(*DeleteGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OpenAuth_AssignUserToGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AssignUserToGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OpenAuthServer).AssignUserToGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OpenAuth_AssignUserToGroup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OpenAuthServer).AssignUserToGroup(ctx, req.(*AssignUserToGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OpenAuth_RemoveUserFromGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveUserFromGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OpenAuthServer).RemoveUserFromGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OpenAuth_RemoveUserFromGroup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OpenAuthServer).RemoveUserFromGroup(ctx, req.(*RemoveUserFromGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OpenAuth_ListGroupUsers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListGroupUsersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OpenAuthServer).ListGroupUsers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OpenAuth_ListGroupUsers_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OpenAuthServer).ListGroupUsers(ctx, req.(*ListGroupUsersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OpenAuth_ListUserGroups_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListUserGroupsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OpenAuthServer).ListUserGroups(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OpenAuth_ListUserGroups_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OpenAuthServer).ListUserGroups(ctx, req.(*ListUserGroupsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OpenAuth_AssignPermissionToGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AssignPermissionToGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OpenAuthServer).AssignPermissionToGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OpenAuth_AssignPermissionToGroup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OpenAuthServer).AssignPermissionToGroup(ctx, req.(*AssignPermissionToGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OpenAuth_RemovePermissionFromGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemovePermissionFromGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OpenAuthServer).RemovePermissionFromGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OpenAuth_RemovePermissionFromGroup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OpenAuthServer).RemovePermissionFromGroup(ctx, req.(*RemovePermissionFromGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OpenAuth_ListGroupPermissions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListGroupPermissionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OpenAuthServer).ListGroupPermissions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OpenAuth_ListGroupPermissions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OpenAuthServer).ListGroupPermissions(ctx, req.(*ListGroupPermissionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OpenAuth_AssignPermissionToUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AssignPermissionToUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OpenAuthServer).AssignPermissionToUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OpenAuth_AssignPermissionToUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OpenAuthServer).AssignPermissionToUser(ctx, req.(*AssignPermissionToUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OpenAuth_RemovePermissionFromUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemovePermissionFromUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OpenAuthServer).RemovePermissionFromUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OpenAuth_RemovePermissionFromUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OpenAuthServer).RemovePermissionFromUser(ctx, req.(*RemovePermissionFromUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OpenAuth_ListUserPermissions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListUserPermissionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OpenAuthServer).ListUserPermissions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OpenAuth_ListUserPermissions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OpenAuthServer).ListUserPermissions(ctx, req.(*ListUserPermissionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OpenAuth_GetUserEffectivePermissions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUserEffectivePermissionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OpenAuthServer).GetUserEffectivePermissions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OpenAuth_GetUserEffectivePermissions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OpenAuthServer).GetUserEffectivePermissions(ctx, req.(*GetUserEffectivePermissionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OpenAuth_SignUp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SignUpRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OpenAuthServer).SignUp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OpenAuth_SignUp_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OpenAuthServer).SignUp(ctx, req.(*SignUpRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OpenAuth_VerifyEmail_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VerifyEmailRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OpenAuthServer).VerifyEmail(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OpenAuth_VerifyEmail_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OpenAuthServer).VerifyEmail(ctx, req.(*VerifyEmailRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OpenAuth_VerifyPhone_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VerifyPhoneRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OpenAuthServer).VerifyPhone(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OpenAuth_VerifyPhone_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OpenAuthServer).VerifyPhone(ctx, req.(*VerifyPhoneRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OpenAuth_ResendVerification_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SendVerificationCodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OpenAuthServer).ResendVerification(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OpenAuth_ResendVerification_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OpenAuthServer).ResendVerification(ctx, req.(*SendVerificationCodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OpenAuth_CheckUsername_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CheckUsernameRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OpenAuthServer).CheckUsername(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OpenAuth_CheckUsername_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OpenAuthServer).CheckUsername(ctx, req.(*CheckUsernameRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OpenAuth_CheckEmail_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CheckEmailRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OpenAuthServer).CheckEmail(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OpenAuth_CheckEmail_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OpenAuthServer).CheckEmail(ctx, req.(*CheckEmailRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OpenAuth_GetUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OpenAuthServer).GetUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OpenAuth_GetUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OpenAuthServer).GetUser(ctx, req.(*GetUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OpenAuth_UpdateUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OpenAuthServer).UpdateUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OpenAuth_UpdateUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OpenAuthServer).UpdateUser(ctx, req.(*UpdateUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OpenAuth_ChangePassword_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChangePasswordRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OpenAuthServer).ChangePassword(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OpenAuth_ChangePassword_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OpenAuthServer).ChangePassword(ctx, req.(*ChangePasswordRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OpenAuth_ListUsers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListUsersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OpenAuthServer).ListUsers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OpenAuth_ListUsers_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OpenAuthServer).ListUsers(ctx, req.(*ListUsersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OpenAuth_DeleteUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OpenAuthServer).DeleteUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OpenAuth_DeleteUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OpenAuthServer).DeleteUser(ctx, req.(*DeleteUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OpenAuth_CreateProfile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateProfileRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OpenAuthServer).CreateProfile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OpenAuth_CreateProfile_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OpenAuthServer).CreateProfile(ctx, req.(*CreateProfileRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OpenAuth_ListUserProfiles_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListUserProfilesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OpenAuthServer).ListUserProfiles(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OpenAuth_ListUserProfiles_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OpenAuthServer).ListUserProfiles(ctx, req.(*ListUserProfilesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OpenAuth_UpdateProfile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateProfileRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OpenAuthServer).UpdateProfile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OpenAuth_UpdateProfile_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OpenAuthServer).UpdateProfile(ctx, req.(*UpdateProfileRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OpenAuth_DeleteProfile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteProfileRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OpenAuthServer).DeleteProfile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OpenAuth_DeleteProfile_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OpenAuthServer).DeleteProfile(ctx, req.(*DeleteProfileRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OpenAuth_SignIn_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SignInRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OpenAuthServer).SignIn(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OpenAuth_SignIn_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OpenAuthServer).SignIn(ctx, req.(*SignInRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OpenAuth_RefreshToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RefreshTokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OpenAuthServer).RefreshToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OpenAuth_RefreshToken_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OpenAuthServer).RefreshToken(ctx, req.(*RefreshTokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OpenAuth_Logout_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LogoutRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OpenAuthServer).Logout(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OpenAuth_Logout_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OpenAuthServer).Logout(ctx, req.(*LogoutRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OpenAuth_ValidateToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ValidateTokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OpenAuthServer).ValidateToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OpenAuth_ValidateToken_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OpenAuthServer).ValidateToken(ctx, req.(*ValidateTokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OpenAuth_ListUserSessions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListUserSessionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OpenAuthServer).ListUserSessions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OpenAuth_ListUserSessions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OpenAuthServer).ListUserSessions(ctx, req.(*ListUserSessionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OpenAuth_TerminateSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TerminateSessionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OpenAuthServer).TerminateSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OpenAuth_TerminateSession_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OpenAuthServer).TerminateSession(ctx, req.(*TerminateSessionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// OpenAuth_ServiceDesc is the grpc.ServiceDesc for OpenAuth service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var OpenAuth_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "v1.OpenAuth",
	HandlerType: (*OpenAuthServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Ping",
			Handler:    _OpenAuth_Ping_Handler,
		},
		{
			MethodName: "CreatePermission",
			Handler:    _OpenAuth_CreatePermission_Handler,
		},
		{
			MethodName: "GetPermission",
			Handler:    _OpenAuth_GetPermission_Handler,
		},
		{
			MethodName: "ListPermissions",
			Handler:    _OpenAuth_ListPermissions_Handler,
		},
		{
			MethodName: "UpdatePermission",
			Handler:    _OpenAuth_UpdatePermission_Handler,
		},
		{
			MethodName: "DeletePermission",
			Handler:    _OpenAuth_DeletePermission_Handler,
		},
		{
			MethodName: "CreateGroup",
			Handler:    _OpenAuth_CreateGroup_Handler,
		},
		{
			MethodName: "GetGroup",
			Handler:    _OpenAuth_GetGroup_Handler,
		},
		{
			MethodName: "ListGroups",
			Handler:    _OpenAuth_ListGroups_Handler,
		},
		{
			MethodName: "UpdateGroup",
			Handler:    _OpenAuth_UpdateGroup_Handler,
		},
		{
			MethodName: "DeleteGroup",
			Handler:    _OpenAuth_DeleteGroup_Handler,
		},
		{
			MethodName: "AssignUserToGroup",
			Handler:    _OpenAuth_AssignUserToGroup_Handler,
		},
		{
			MethodName: "RemoveUserFromGroup",
			Handler:    _OpenAuth_RemoveUserFromGroup_Handler,
		},
		{
			MethodName: "ListGroupUsers",
			Handler:    _OpenAuth_ListGroupUsers_Handler,
		},
		{
			MethodName: "ListUserGroups",
			Handler:    _OpenAuth_ListUserGroups_Handler,
		},
		{
			MethodName: "AssignPermissionToGroup",
			Handler:    _OpenAuth_AssignPermissionToGroup_Handler,
		},
		{
			MethodName: "RemovePermissionFromGroup",
			Handler:    _OpenAuth_RemovePermissionFromGroup_Handler,
		},
		{
			MethodName: "ListGroupPermissions",
			Handler:    _OpenAuth_ListGroupPermissions_Handler,
		},
		{
			MethodName: "AssignPermissionToUser",
			Handler:    _OpenAuth_AssignPermissionToUser_Handler,
		},
		{
			MethodName: "RemovePermissionFromUser",
			Handler:    _OpenAuth_RemovePermissionFromUser_Handler,
		},
		{
			MethodName: "ListUserPermissions",
			Handler:    _OpenAuth_ListUserPermissions_Handler,
		},
		{
			MethodName: "GetUserEffectivePermissions",
			Handler:    _OpenAuth_GetUserEffectivePermissions_Handler,
		},
		{
			MethodName: "SignUp",
			Handler:    _OpenAuth_SignUp_Handler,
		},
		{
			MethodName: "VerifyEmail",
			Handler:    _OpenAuth_VerifyEmail_Handler,
		},
		{
			MethodName: "VerifyPhone",
			Handler:    _OpenAuth_VerifyPhone_Handler,
		},
		{
			MethodName: "ResendVerification",
			Handler:    _OpenAuth_ResendVerification_Handler,
		},
		{
			MethodName: "CheckUsername",
			Handler:    _OpenAuth_CheckUsername_Handler,
		},
		{
			MethodName: "CheckEmail",
			Handler:    _OpenAuth_CheckEmail_Handler,
		},
		{
			MethodName: "GetUser",
			Handler:    _OpenAuth_GetUser_Handler,
		},
		{
			MethodName: "UpdateUser",
			Handler:    _OpenAuth_UpdateUser_Handler,
		},
		{
			MethodName: "ChangePassword",
			Handler:    _OpenAuth_ChangePassword_Handler,
		},
		{
			MethodName: "ListUsers",
			Handler:    _OpenAuth_ListUsers_Handler,
		},
		{
			MethodName: "DeleteUser",
			Handler:    _OpenAuth_DeleteUser_Handler,
		},
		{
			MethodName: "CreateProfile",
			Handler:    _OpenAuth_CreateProfile_Handler,
		},
		{
			MethodName: "ListUserProfiles",
			Handler:    _OpenAuth_ListUserProfiles_Handler,
		},
		{
			MethodName: "UpdateProfile",
			Handler:    _OpenAuth_UpdateProfile_Handler,
		},
		{
			MethodName: "DeleteProfile",
			Handler:    _OpenAuth_DeleteProfile_Handler,
		},
		{
			MethodName: "SignIn",
			Handler:    _OpenAuth_SignIn_Handler,
		},
		{
			MethodName: "RefreshToken",
			Handler:    _OpenAuth_RefreshToken_Handler,
		},
		{
			MethodName: "Logout",
			Handler:    _OpenAuth_Logout_Handler,
		},
		{
			MethodName: "ValidateToken",
			Handler:    _OpenAuth_ValidateToken_Handler,
		},
		{
			MethodName: "ListUserSessions",
			Handler:    _OpenAuth_ListUserSessions_Handler,
		},
		{
			MethodName: "TerminateSession",
			Handler:    _OpenAuth_TerminateSession_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/openauth/v1/openauth.proto",
}
