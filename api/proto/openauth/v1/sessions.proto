syntax = "proto3";
package v1;
import "proto/openauth/v1/users.proto";
import "validate/validate.proto";
option go_package = "./openauth_v1";
// ===== AUTHENTICATION & SESSION MANAGEMENT =====

message SignInMetadata {
    optional string device_id = 1;     // Unique device identifier
    optional string device_name = 2;   // Human-readable device name
    optional string device_type = 3;   // web, mobile, desktop, tablet
    optional double lat = 4;
    optional double long = 5;
}
// SignInRequest for user authentication
message SignInRequest {
    string username = 1 [(validate.rules).string = {
        min_len: 1,
        max_len: 255
    }];
    optional string password = 2 [(validate.rules).string = {
        min_len: 1,
        max_len: 128
    }];
    optional string otp = 3 [(validate.rules).string = {
        min_len: 4,
        max_len: 10,
        pattern: "^[0-9]+$"
    }];
    optional bool remember_me = 4;
    optional SignInMetadata metadata = 5;
    optional bool profiles = 6;
    optional bool include_permissions = 7;
    optional int64 verification_id = 8 [(validate.rules).int64.gt = 0];
}

// SignInResponse with authentication tokens and user data
message SignInResponse {
    string access_token = 1;
    string refresh_token = 2;
    int64 expires_at = 3;              // Access token expiration (Unix timestamp)
    int64 refresh_expires_at = 4;      // Refresh token expiration (Unix timestamp)
    User user = 5;
    string session_id = 6;             // Session UUID for tracking
    string message = 7;
}

// RefreshTokenRequest to refresh access token
message RefreshTokenRequest {
    string refresh_token = 1 [(validate.rules).string = {
        min_len: 1,
        max_len: 1024
    }];
    optional string device_id = 2 [(validate.rules).string.max_len = 100];
    optional bool profiles = 3;
    optional bool include_permissions = 4;
}

// RefreshTokenResponse with new tokens
message RefreshTokenResponse {
    string access_token = 1;
    string refresh_token = 2;          // New refresh token (rotation)
    int64 expires_at = 3;
    int64 refresh_expires_at = 4;
    string message = 5;
}

// LogoutRequest to end user session
message LogoutRequest {
    optional string session_id = 1;    // Specific session to logout
    optional bool all_sessions = 2;    // Logout from all devices
}

// LogoutResponse
message LogoutResponse {
    bool success = 1;
    string message = 2;
    int32 sessions_terminated = 3;     // Number of sessions ended
}

// ValidateTokenRequest to check token validity
message ValidateTokenRequest {
    string access_token = 1;
}

// ValidateTokenResponse
message ValidateTokenResponse {
    bool valid = 1;
    string message = 2;
    optional User user = 3;            // User info if token is valid
    optional int64 expires_at = 4;     // Token expiration
}

// Session information
message Session {
    string id = 1;                     // Session UUID
    string user_id = 2;                // User UUID
    string device_id = 3;
    string device_name = 4;
    string device_type = 5;
    string user_agent = 6;
    string ip_address = 7;
    string location = 8;
    bool is_active = 9;
    int64 expires_at = 10;
    int64 last_activity_at = 11;
    int64 created_at = 12;
}

// ListUserSessionsRequest to get active sessions
message ListUserSessionsRequest {
    string user_uuid = 1;
    int32 limit = 2;
    int32 offset = 3;
    optional bool active_only = 4;
}

// ListUserSessionsResponse
message ListUserSessionsResponse {
    repeated Session sessions = 1;
}

// TerminateSessionRequest to end specific session
// If user_id is provided, terminate all sessions for the user and keep the specified session
// If user_id is not provided then, terminate session provided.
message TerminateSessionRequest {
    string session_id = 1;
    optional string user_id = 2; // if user_id is provided, terminate all sessions for the user and keep the specified session
}

// TerminateSessionResponse
message TerminateSessionResponse {
    bool success = 1;
    string message = 2;
}
